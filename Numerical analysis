#include <stdio.h>
#include <stdlib.h>
void print_1DArray(double *A, int N);
void print_2DArray(double (*A)[], int N);
void gauss_eliminate(double (*A)[], double *b, int N);
double *slover(double (*A)[], double *b, int N);
int main()
{
    printf("Hello world!\n");
    // 我们在这合理来创建一个矩阵的尺寸大小
    int N = 3;
    double A[3][3] = {1, 2, 3, 2, 5, 2, 3, 1, 5};
    double b[3] = {14, 18, 20};
    printf("您当前输入的矩阵为:\n");
    print_2DArray(A, N);
    printf("您当前输入的b矩阵为:\n");
    print_1DArray(b, N);
    printf("接下来进行上三角形的划分:\n");
    gauss_eliminate(A, b, N);
    printf("上三角形划分之后的系数矩阵为:\n");
    print_2DArray(A, N);
    printf("对应的b矩阵为:\n");
    print_1DArray(b, N);
    // 接下来我们便需要来求解
    double *x = NULL;
    x = slover(A, b, N);
    // 计算过后的x向量为:
    printf("计算完成的x矩阵为:\n");
    print_1DArray(x, N);
    // 接下来我们需要来释放动态开辟的内存空间
    free(x);
    return 0;
    
}

/*接下来创建一个计算方程组的函数-> 上三角求解*/
double *slover(double (*A)[3], double *b, int N){
    // 这里要求您所输入的系数矩阵是已经化为上三角型之后的矩阵
    // 但是这里并没有添加参数的类型或者数据的判断,
    // 这里我们来动态开辟内存
    double *x = (double *)malloc(N);
    double sum_val = 0.0;
    for(int d=N-1; d>=0; d--){
        // 首先确定的是当前结果的最后一个元素
        sum_val = 0;
        for(int m=N-1; m> d; m--){
            sum_val += A[d][m] * x[m];
        }
        x[d] = (b[d] - sum_val) / A[d][d];
    }
    return x;
}

void gauss_eliminate(double (*A)[3], double *b, int N){
    /*列主元消去法，需要遍历对应的列来找到对应的最大值，然后将其换到主元上去*/
    int max_ele_index = 0;;
    double eff = 0.0;
    for(int i=0; i<N; i++){
        max_ele_index = i;
        for(int j=i+1; j<N; j++){
            if(abs(A[j][i]) > abs(A[max_ele_index][i])){
                max_ele_index = j;
            }
        }
        /*待跳出循环后，便说明我们已经找到了当前列上的最大元素值*/
        /*将其交换到主元上去*/
        /*二维数组的存储方式是按行排列的*/
        double temp = 0.0;
        for(int d=0; d<N; d++){
            temp = A[i][d];
            A[i][d] = A[max_ele_index][d];
            A[max_ele_index][d] = temp;
        }
        // 这里要注意我们同样需要交换b中的两个对应位置上的值
        double tet = 0.0;
        tet = *(b+i);
        *(b+i) = *(b+max_ele_index);
        *(b+max_ele_index) = tet;
        // 交换完成之后，说明当前的主元已经选定了
        // 接下来我们需要进行上三角型的划分
        printf("第%d次交换:\n", i);
        print_2DArray(A, N);
        printf("\n");
        print_1DArray(b, N);
        for(int d=i+1; d<N; d++){
            // 我们要把i行上的元素作用到d行上去
            // 列的处理应该是从i列开始的地方
            eff = A[d][i] / A[i][i];
            for(int m=i; m<N; m++){
                A[d][m] -= A[i][m] * eff;
            }
            // 我们这里同样需要进行b对应位置上计算
            b[d] -= eff * b[i];
        }
    }
}
/*创建一个方法，来打印输出二位数组*/
void print_2DArray(double (*A)[3], int N){
    for(int i=0; i<N; i++){
        for(int j=0; j<N; j++){
            printf("%lf\t", A[i][j]);
        }
        printf("\n");
    }
}

/*创建一个方法，来打印输出一维数组*/
void print_1DArray(double *A, int N){
    for(int i=0; i<N; i++){
        printf("%lf\t", A[i]);
    }
    printf("\n");
}
